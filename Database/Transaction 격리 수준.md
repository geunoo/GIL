# Transaction 격리 수준

## 개념

Transaction ACID중 고립성의 수준을 결정하는 것으로, 
트랜잭션끼리의 영향의 강도를 결정하는 것이다.

## 격리 수준

총 4가지 격리수준이 존재한다.

- READ UNCOMMITED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

아래로 내려갈수록 격리수준이 점점 강해진다.

격리 수준이 강해진다면 데이터 무결성을 보장할 수 있지만 성능저하가 아주 심각하다. 
실무에서는 주로 READ COMMITTED나 REPEATABLE READ를 사용한다고 한다.

### READ UNCOMMITED

한 트랜잭션이 수행중일때, 다른 트랜잭션이 해당 트랜잭션의 변경 내용에 접근가능하다.

1. A 트랜잭션에서 통장에 10000원인 상태에서 1000원 입금
2. 아직 커밋안한 상태
3. 트랜잭션 B에서 통장 잔액 조회
4. 트랜잭션 B는 11000원이 조회됨 
5. 트랜잭션 A가 롤백됨
6. 데이터베이스는 10000원이지만 B는 11000원이 조회됨

이런식으로 데이터 정합성에 문제가 생긴다.

RDBMS 표준에서는 격리수준으로 인정도 안해준다고 한다.

### READ COMMITTED

한 트랜잭션이 실행중일때, 해당 트랜잭션에 다른 트랜잭션은 접근할 수 없다.
얼핏보면 문제가 없어보이지만, 문제가 하나 숨어있다.

1. A 트랜잭션에서 통장에 10000원인 상태에서 1000원 입금
2. 커밋안한 상태에서 트랜잭션 B에서 잔액 조회
3. 커밋 전이기 때문에 트랜잭션 B에서는 10000원이 조회됨
4. A 트랜잭션이 커밋됨
5. B트랜잭션에서 다시한번 잔액 조회
6. 11000원이 조회됨

이부분에서 하나의 트랜잭션에서 같은 조회쿼리는 항상 같은 결과를 가져와야한다는
REPEATABLE READ를 어기게 된다. (NON-REPEATABLE-READ)

### REPEATABLE READ

READ COMMITTED 수준에서 발생하던 NON-REPEATABLE-READ문제를 해결할 수 있다.

트랜잭션 시작시 시작전에 커밋된 내용들에서만 가져오기 때문에 그렇다.

하지만 Phantom Read가 발생할 수 있다.

같은 트랜잭션에서 같은 조회쿼리를 두번 날렸을때, 첫번째와 두번째때 레코드의 갯수가 다른 것이다.

그 조회한 값이 만일 어떤 범위라면, 그 범위 전체를 보관하지 못해서 발생하는 문제라고 한다.

### ****SERIALIZABLE****

한글로 번역했을때 직렬화라는 뜻인데, 그 뜻 그대로 한번에 하나의 트랜잭션만 실행될 수 있다.

이렇게된다면, 앞에서 말했던 어떠한 문제도 일어나지 않지만
처리성능이 매우 떨어지게된다.